import { getUserMetrics } from "./user";
import {
  MSG_INSUFFICIENT_FUND,
  HTTP_CODE_INSUFFICENT_FUNDS,
  HTTP_CODE_REWARD_ERROR
} from "../config/constants";
import { createError, console500MSG } from "./error";
import Transaction from "../models/Transaction";
import mongoose from "mongoose";

export const calcSum = (arr = [], key) =>
  arr.reduce(
    (sum, transaction) =>
      sum +
      ((transaction[key] === undefined
        ? transaction.availableAmount === undefined
          ? transaction.amount
          : transaction.availableAmount
        : transaction[key]) || 0),
    0
  );

export const validateAccBalanace = async (
  uid,
  amount = 0,
  msg = MSG_INSUFFICIENT_FUND
) => {
  const metrics = await getUserMetrics(uid);

  if (amount > metrics.availBalance)
    throw createError(msg, 400, HTTP_CODE_INSUFFICENT_FUNDS);

  return metrics;
};

export const debitUserAcc = async (uid, amount, transId, investId) => {
  if (!transId)
    transId = (await new Transaction({
      amount,
      user: uid,
      investment: investId,
      paymentType: "fiat",
      currency: "USD",
      transactionType: "withdrawal",
      autoGenerated: true
    }).save())._id;

  const deposits = await Transaction.find({
    user: uid,
    transactionType: "deposit",
    availableAmount: {
      $gt: 0
    },
    status: "confirmed"
  }).sort({
    createdAt: -1
  });

  let tAmt = amount,
    sum = 0;

  if (calcSum(deposits) < tAmt)
    throw createError(MSG_INSUFFICIENT_FUND, 400, HTTP_CODE_INSUFFICENT_FUNDS);

  for (const d of deposits) {
    let bool = false;

    let dAmt = d.availableAmount;

    sum += dAmt;

    if (sum > tAmt) {
      dAmt = sum - tAmt;
      bool = true;
    } else dAmt = 0;

    await d.updateOne({
      availableAmount: dAmt,
      $addToSet: {
        retrievalReference: transId
      }
    });

    if (bool) break;
  }
};

export const rewardReferrals = async (investment, req) => {
  const refs = req.user.referrals;

  for (let i = 0; i < refs.length; i++) {
    const uid = refs[i];

    const pctDefault = {
      starterforex: { 0: 10, 1: 7, 2: 3 }[i],
      professionalforex: { 0: 15, 1: 10, 2: 7 }[i],
      masterforex: { 0: 20, 1: 15, 2: 10 }[i],
      startercrypto: { 0: 5, 1: 5, 2: 5 }[i],
      professionalcrypto: { 0: 10, 1: 10, 2: 10 }[i],
      mastercrypto: { 0: 15, 1: 15, 2: 15 }[i]
    }[investment.plan + investment.tradeType];

    const { pct = pctDefault, amount } = req.query.reward || {};

    const referree = req.user._id || new mongoose.Types.ObjectId(req.user.id);

    try {
      if (
        !!(await Transaction.findOne({
          user: uid,
          ["metadata.referree"]: referree,
          ["metadata.referral"]: uid
        }))
      )
        continue;

      await new Transaction({
        investment: investment.id,
        rewarded: true,
        user: uid,
        amount: amount || (pct / 100) * investment.amount + investment.amount,
        paymentType: "fiat",
        currency: "USD",
        metadata: {
          referree,
          referral: uid
        },
        description: `${pct}% referral commission on ${req.user.fullname ||
          req.user.username} investment!`
      }).save();
    } catch (err) {
      console500MSG(
        err,
        HTTP_CODE_REWARD_ERROR,
        `Failed to reward ${uid} from ${referree}. [investId: ${investment.id}]`
      );
    }
  }
};
