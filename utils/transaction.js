import { getUserMetrics } from "./user";
import {
  MSG_INSUFFICIENT_FUND,
  HTTP_CODE_INSUFFICENT_FUNDS,
  HTTP_CODE_REWARD_ERROR,
} from "../config/constants";
import { createError, console500MSG } from "./error";
import Transaction from "../models/Transaction";
import mongoose from "mongoose";

export const calcSum = (arr = [], key) =>
  arr.reduce(
    (sum, transaction) =>
      sum +
      ((transaction[key] === undefined
        ? transaction.availableAmount === undefined
          ? transaction.amount
          : transaction.availableAmount
        : transaction[key]) || 0),
    0
  );

export const validateAccBalanace = async (
  uid,
  amount = 0,
  msg = MSG_INSUFFICIENT_FUND
) => {
  const metrics = await getUserMetrics(uid);

  if (amount > metrics.availableBalance)
    throw createError(msg, 400, HTTP_CODE_INSUFFICENT_FUNDS);

  return metrics;
};

export const debitUserAcc = async (uid, amount, transId, investId) => {
  if (!transId) // use-case investment
    transId = (
      await new Transaction({
        amount,
        user: uid,
        investment: investId,
        paymentType: "fiat",
        currency: "USD",
        transactionType: "withdrawal",
        autoGenerated: true,
      }).save()
    )._id;

  const deposits = await Transaction.find({
    user: uid,
    transactionType: "deposit",
    availableAmount: {
      $gt: 0,
    },
    status: "confirmed",
  }).sort({
    createdAt: -1,
  });

  let tAmt = amount,
    sum = 0;

  if (calcSum(deposits) < tAmt)
    throw createError(MSG_INSUFFICIENT_FUND, 400, HTTP_CODE_INSUFFICENT_FUNDS);

  for (const d of deposits) {
    let bool = false;

    let dAmt = d.availableAmount;

    sum += dAmt;

    if (sum > tAmt) {
      dAmt = sum - tAmt;
      bool = true;
    } else dAmt = 0;

    await d.updateOne({
      availableAmount: dAmt,
      $addToSet: {
        retrievalReference: transId,
      },
    });

    if (bool) break;
  }
};

export const rewardReferrals = async (investment, req) => {
  const refs = req.user.referrals;

  for (let i = 0; i < refs.length; i++) {
    const uid = refs[i];

    const pctDefault = {
      starterforex: { 0: 10, 1: 7, 2: 3 }[i],
      professionalforex: { 0: 15, 1: 10, 2: 7 }[i],
      masterforex: { 0: 20, 1: 15, 2: 10 }[i],
      startercrypto: { 0: 5, 1: 5, 2: 5 }[i],
      professionalcrypto: { 0: 10, 1: 10, 2: 10 }[i],
      mastercrypto: { 0: 15, 1: 15, 2: 15 }[i],
    }[investment.plan + investment.tradeType];

    const { pct = pctDefault, amount } = req.query.reward || {};

    const referree = req.user._id || new mongoose.Types.ObjectId(req.user.id);

    try {
      if (
        !!(await Transaction.findOne({
          user: uid,
          ["metadata.referree"]: referree,
          ["metadata.referral"]: uid,
        }))
      )
        continue;

      await new Transaction({
        investment: investment.id,
        rewarded: true,
        user: uid,
        amount: amount || (pct / 100) * investment.amount + investment.amount,
        paymentType: "fiat",
        currency: "USD",
        metadata: {
          referree,
          referral: uid,
        },
        description: `${pct}% referral commission on ${
          req.user.fullname || req.user.username
        } investment!`,
      }).save();
    } catch (err) {
      console500MSG(
        err,
        HTTP_CODE_REWARD_ERROR,
        `Failed to reward ${uid} from ${referree}. [investId: ${investment.id}]`
      );
    }
  }
};

export const getCurrencySymbol = (currency = "USD") => {
  return { usd: "$", euro: "€", eur: "€" }[currency.toLowerCase()] || "$";
};
